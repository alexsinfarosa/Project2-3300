<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Project 2</title>
	
	<!-- Mobile Specific Meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<!-- Custom Style Sheet -->
	<link rel="stylesheet" href="main.css">

	<!-- Google fonts -->
	<link href='http://fonts.googleapis.com/css?family=Roboto+Condensed:400,700' rel='stylesheet' type='text/css'>

	<!-- D3.js -->
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

</head>
<body>

<input type="button" value="England" onclick="selectCountry('England')">
<input type="button" value="France" onclick="selectCountry('France')">
<input type="button" value="Italy" onclick="selectCountry('Italy')">

<select id="ddlViewBy" onchange="selectCountry(this.value)">
  <option value="England">England</option>
  <option value="France" selected="selected">France</option>
  <option value="Italy">Italy</option>
</select>

	<script>

    //creating proper json formats
    //rootName will be the name of the country
    function buildJSONHierarchy(csv, rootName){
        var root = {"name": rootName, "children": []};
        for(var i = 1; i < csv.length; i++){
            var currentLine = csv[i];
            var team1Name = currentLine["Team 1"];
            var team2Name = currentLine["Team 2"];
            var FT = currentLine["FT"];
            var HT = currentLine["HT"];
            var date = currentLine["Date"];

            //Try to find existing team1
            var team1 = null;
            for(var j = 0; j < root["children"].length; j++){
                var child = root["children"][j];
                if(child["name"] == team1Name){
                    team1 = child;
                    break;
                }
            }

            //create new team1 object
            if (team1 == null){
              team1 = {"name": team1Name, "children": []};
              root["children"].push(team1);
            }

            var team2 = {"name": team2Name, "HT": HT, "FT": FT, "Date": date}
            team1["children"].push(team2);
        }
        return root;
    }

    var m = [20, 120, 20, 120],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root;

    var tree = d3.layout.tree()
        .size([h, w]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var vis = d3.select("body").append("svg:svg")
        .attr("width", w + m[1] + m[3])
        .attr("height", h + m[0] + m[2])
        .append("svg:g")
        .attr("transform", "translate(" + m[3] + "," + m[0] + ")");


    var random = Math.floor(Math.random() * 3);
    
    // Randomly display one of 3 country
    if (random == 0) {
        var country = "England";
    } else if(random == 1) {
        var country = "France";   
    } else if(random == 2) {
        var country = "Italy";
    }

    // dropdown list code
    var e = document.getElementById("ddlViewBy");
    var country = e.options[e.selectedIndex].value;
            
    d3.csv(country + ".csv", function(data) {
        newJSON = buildJSONHierarchy(data, country);
        root = newJSON;
        root.x0 = h / 2;
        root.y0 = 0;

        function toggleAll(d) {
            if (d.children) {
                d.children.forEach(toggleAll);
                toggle(d);
            }
        }

        // Initialize the display to show a few nodes.
        root.children.forEach(toggleAll);
        update(root);
    });

    function selectCountry(countryName) {
            var country = countryName;

            // Update graph after clicking button 
            d3.csv(country + ".csv", function(data) {
                newJSON = buildJSONHierarchy(data, country);
                root = newJSON;
                root.x0 = h / 2;
                root.y0 = 0;

                function toggleAll(d) {
                    if (d.children) {
                        d.children.forEach(toggleAll);
                        toggle(d);
                    }
                }

                // Initialize the display to show a few nodes.
                root.children.forEach(toggleAll);
                update(root);
            });
        
        }

    function update(source) {
        var duration = d3.event && d3.event.altKey ? 5000 : 500;

        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse();

        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodes…
        var node = vis.selectAll("g.node")
          .data(nodes, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("svg:g")
          .attr("class", "node")
          .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
          .on("click", function(d) { toggle(d); update(d); })
          .on("mouseover", function(d) {
            var g = d3.select(this); // The node
            // The class is used to remove the additional text later
            // console.log(d.FT == null);
            if (d.FT != null) {
              var info = g.append("text")
                .classed("info", true)
                .attr("x", 125)
                .attr("y", 4)
                .text( "Date: " + d.Date )
                .append("tspan").text("HT: " + d.HT).attr("x", 125).attr("y", 20)
                .append("tspan").text("FT: " + d.FT).attr("x", 125).attr("y", 36);
              }
            })
          .on("mouseout", function() {
            // Remove the info text on mouse out.
            d3.select(this).select('text.info').remove();
          });

        nodeEnter.append("svg:circle")
          .attr("r", 1e-6)
          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter.append("svg:text")
          .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
          .attr("dy", ".35em")
          .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
          .text(function(d) {
            if (! d.FT){
              return d.name;}
              else{
                return d.FT + " " + d.name; }})
          .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate.select("circle")
          .attr("r", 4.5)
          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#CF000F"; });

        nodeUpdate.select("text")
          .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
          .remove();

        nodeExit.select("circle")
          .attr("r", 1e-6);

        nodeExit.select("text")
          .style("fill-opacity", 1e-6);

        // Update the links…
        var link = vis.selectAll("path.link")
          .data(tree.links(nodes), function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("svg:path", "g")
          .attr("class", "link")
          .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal({source: o, target: o});
          })
          .transition()
          .duration(duration)
          .attr("d", diagonal);

        // Transition links to their new position.
        link.transition()
          .duration(duration)
          .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
          .duration(duration)
          .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
            return diagonal({source: o, target: o});
          })
          .remove();

        // Stash the old positions for transition.
        nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
        });
    }

    // Toggle children.
    function toggle(d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
            } else {
            d.children = d._children;
            d._children = null;
        }
    } 


</script>

	<!-- JQuery -->
	<script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>

	<!-- MAIN JS-->
	<script src="scripts.js"></script>
</body>
</html>